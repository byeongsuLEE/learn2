
# 스케줄링
운영체제가 스레드를 어떻게 스케줄링 하는지 , 스케줄링 관점으로 알아봅시다.

운영체제는 내부에 스케줄링 큐를 가지고 잇고, 각각의 스레드는 스케줄링 큐에서 대기한다.

cpu에 어떤 프로그램이 얼마난큼 실행될지 운영체제가 결정
이것을 스케줄링이라 한다.
이때 단순히  시간으로만 작업을 분할하지는 않고, cpu를 최대한 활용할 수 있는 다양한 우선순위와 최적화 기법을 사용한다.
우리는 운영체제가 스케줄링을 수행하고, CPU를 최대한 사용하면서 작업이 골고루 수행될 수 있게 최적화한다는 정도로 이해하면 충분하다.



##  단일 코어 스케줄링
 스레드1,2,3이 있을 때 스케줄링 큐에 넣고
 cpu 코어가 하나의 스레드를 실행하는 방식을 말함
 
cpu코어에서 하나의 스레드가 실행되고 멈추고 다른 스레드를 실행하고 이전 스레드를 큐에 넣고 
나중에 다시 실행하는 방식으로 동작합니다.

## 멀티 코어 스케줄링
단일 코어 스케줄링처럼 동작하고 두 개 이상의 코어가 동시에 스레드를 실행하는 것을 말한다.


## 프로세스 스레드와 스케줄 - 정리
멀티태스킹과 스케줄링
- 멀티 태스킹이란 동시에 여러 작업을 수행하는 것을말한다.
- 이를 위해 운영체제는 스케줄링이라는 기법을 사용한다.
- 스케줄링은 cpu 시간을 여러 작업에 나누어 배분하는 방법이다.

프로세스와 스레드
- 프로세스는 실행 중인 프로그램의 인스턴스이다. 각 프로세스는 독립적인 메모리 공간을 가지며, 운영체제에서 독립된 실행 단위로 취급된다.
- 스레드는 프로세스 내에서 실행되는 작은 단위이다. 여러 스레드는 하나의 프로세스 내에서 자원을 공유하며, 프로세스의 코드, 데이터, 시스템 자원등을 공유한다. 실제로 CPU에 의해 실행되는 단위는 스레드다.

프로세서
- 멀티 프로세서의 프로세서, 즉 CPU를 말한다.

프로세스의 역할
- 프레스는 실행 환경을 제공합니다. 여기에는 메모리 공간, 파일 핸들, 시스템 자원(네트워크 연결) 등이 포함된다. 이는 프로세스가 컨테이너 역할을 한다는 의미이다.
- 프로세스 자체는 운영체제의 스케줄러에 의해 직접 실행되지 않으며, 프로세스 내의 스레드가 실행된다.
- 참고로 1개의 프로세스 안에 하나의 스레드만 실행되는 경우도 있고, 1개 프로세스 안에 여러개의 스레드가 실행되는 경우가 있다.


# 컨텍스트 스위칭
현재 작업하는 문맥을 뜻한다. 현재 작업하는 문맥이 변하기 때문에 컨텍스트 스위칭이다.
컨텍스트 스위칭 과정에서 이전에 실행중인 값으 메모리에 잠깐 저장하고, 이후에 다시 실행하는 시점에 저장된 값을 CPU에 다시 불러야한다.
이 과정에서 비용이 발생한다.

멀티스레드는 대부분 효율적이지만 , 컨텍스트 스위칭 과정에서 항상 효율적인 것은 아니다.

실무에서는 CPU+1 개수만큼 스레드를 가져가면 좋을 수 도있음
항상 그런건아님

## CPU 바운드 작업 VS I/O 바운드 작업
각각의 스레드가 하는 작업을 크게 2가지로 구분할 수있다.

- CPU-바운드 작업 (CPU-BOUND TASKS)
  - cpu 많이 쓰는 작업
- I/0 바운드 작업
  - 디스크, 네트워크 파일 시스템 등과 같은 입출력 작업을 많이 요규하는 작업을 의미한다.
  - 거의 CPU를 안쓰고 대기해서 I/O 작업이 완료될까지 대기한다.

## 웹 애플리케이션 서버
분야마다 다르겠지만, 실무에서는 CPU 바운드 작어보다, I/O 바운드 작업이 많다.

## 데몬 스레드 vs 사용자 스레드

## 사용자 스레드 
- 일반적으로 우리가 사용하는 스레드
- 프로그램의 주요 작업을 수행
- 작업이 완료될 때까지 실행
- 모든 user 스레드가 종료되면 JVM도 종료된다.

## 데몬 스레드
- 백그라운드에서 보조적인 작업을 수행한다.
- 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료된다.
- 옵션을 통해 데몬 스레드를 생성할 수 있음
- daemonThread.setDaemon(true);   데몬이라면 main 이 끝나면 데몬 스레드의 동작은 멈춰버린다.


## 스레드를 만드는 방법 두 가지
1. extend 
2. Runnable (실무)


## extends 의 한계
- 다중 상속이 안되기 떄문에 thread 클래스를 상속받을 수 없을 수도있음
- runnable을 사용합시다.

## runnable 장점
- 상속의 자유로움
- 코드의 분리 : 스레드와 실행할 작업을 분리하여 가독성 업
- 여러 스레드가 동일한 ruannble 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.

## 스레드의 상태 및 특징
- 스레드 id는 중복이 될 수 없지만, 이름은 중복이 가능하다.

- 스레드 우선순위
  - 개발자가 어떤 스레드를 우선으로 실행해줘라고 희망하는 거임 
  - 우선순위는 기본적으로 5다.
  - 높으면 많이 실행함
  - 높다고 항상 더 많이 실행되는게 아님
  - 실전에서 거의 안씀
- 스레드 그룹
  - 자주 사용 안함 
  - 기본적으로 모든 스레드는 그룹에 포함됨
  - 여러 스레드를 하나의 그룹으로 묶어서 특정 작업을 할 수 있음
  - 스레드는 부모에서 생성이 되기 때문에 부모스레드는 main임
  - 스레드는 기본 main 그룹에 포함되어 있다.

- 스레드의 상태
  - Thread.state 중 하나의 값
  - NEW : 스레드가 아직 시작되지 않는 상태
  - RUNNABLE : 스케줄러 대기열에 있거나 실행되고 있는 상태
  - BLOCKED : 스레드가 동기화 락을 기다리고 있는 상태 
  - WAITING : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태
    - 파일을 불러오거나 읽을 떄 기다리는 시간
  - TIMED_WAITING : 일정 시간 기다리는 상태
    - 시간 제한을 두고 일정 시간 이상 기다리는 상태
  - TERMINATED : 스레드가 실행을 마친 상태


## 스레드의 생명 주기
1. NEW -> RUNNABLE(BLOCK, WAITING, TIME_WAITING) -> Terminate

## 스레드 join
해당 스레드를 기다리고 실행하는 작업 
waiting과 같다.



